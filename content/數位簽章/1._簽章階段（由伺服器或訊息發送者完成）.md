加密方法介紹加密方法介紹

非對稱加密的兩種用途

總結

🔸 使用同一把金鑰來「加密」與「解密」。

📦 範例：

金鑰：K
加密：Ciphertext = Encrypt(K, Plaintext)
解密：Plaintext = Decrypt(K, Ciphertext)


💡 意思是：

- 傳送方與接收方要事先「共用」同一把金鑰 K；

- 拿到密文的人，只要知道 K，就能解出原文。

🧩 舉例：

你用密碼壓縮一個 zip 檔給朋友，只要知道密碼（=金鑰）的人都能打開。

📌 缺點：

- 難在「如何安全地把金鑰交給對方」。

🔸 使用一對不同的金鑰：「公鑰 (Public Key)」與「私鑰 (Private Key)」。

這兩把金鑰互相關聯：

- 用公鑰加密 → 只能用對應的私鑰解密。

- 用私鑰加密（簽章） → 只能用對應的公鑰驗證。

📦 範例：

加密：Ciphertext = Encrypt(PublicKey, Plaintext)
解密：Plaintext = Decrypt(PrivateKey, Ciphertext)


💡 意思是：

- 公鑰可以公開給全世界；

- 私鑰必須由擁有者自己保密；

- 即使知道公鑰，也不可能在可行時間內推算出私鑰（靠數學難題，例如大質數分解、橢圓曲線離散對數）。

非對稱加密不只用來「加密資料」，還能用來「數位簽章」。

- 非對稱加密（公鑰/私鑰）只在握手時用來驗身分與安全交換對稱金鑰。

- 對稱加密（同一把金鑰）在資料傳輸階段負責高效加解密。

- 現代網站使用 TLS 1.3 + ECDHE，具備前向安全。

- Client（用戶端）：你的瀏覽器或 App。

- Server（伺服器）：網站 / API 端。

- 伺服器憑證：含伺服器公鑰與網域資訊，由 CA 簽發（身分證）。

- CA（憑證機構）：大家信任的「發證機關」。

- Session Key（會話金鑰）：對稱加密用的隨機金鑰，僅用於當次連線。

- mTLS：雙向驗證，伺服器也要求客戶端出示憑證。

後續資料全靠對稱加密，所以這步是整個安全的關鍵。

### A. 傳統（TLS 1.2 的 RSA Key Transport，概念易懂）

Client 產生一把隨機的 Session Key（對稱金鑰）。

用 伺服器公鑰 將這把 Session Key 加密。

傳給 Server。

Server 用自己的 私鑰 解開得到 Session Key。

之後雙方都知道同一把 Session Key → 改用對稱加密傳輸。

### B. 現代（TLS 1.3 / TLS 1.2 ECDHE，建議的）

Client 與 Server 各自生成「臨時（ephemeral）公私鑰對」。

雙方交換臨時公鑰（就算被旁觀也無妨）。

利用 Diffie-Hellman 運算，各自計算出相同的共享祕密。

由共享祕密導出 Session Key。

好處：前向安全（就算未來伺服器私鑰外洩，也解不了今天的歷史流量）。

重點釐清：對稱加密沒有「公鑰」。對稱只有一把金鑰；

- 若伺服器回 CertificateRequest，代表要做雙向驗證：

適用內網、金流、etcd/K8s 等高敏感情境。

- 雙方以 Session Key 對「握手完成」訊息加密與驗證，確認彼此能正確解密。

- 自此之後：所有 HTTP/HTTP2/HTTP3 的請求/回應都在對稱加密通道內進行（例如 AES、ChaCha20）。

- 握手時傳的是憑證（公鑰）或臨時公鑰，不是私鑰。

- 真正的 Session Key 不是明文傳的（RSA 方式被公鑰包起來；ECDHE 方式從私鑰計算來）。

- 沒有伺服器私鑰（RSA）或雙方臨時私鑰（ECDHE），旁觀者無法復原 Session Key，自然解不了密文。

- TLS 1.3 + ECDHE 提供前向安全：就算往後某天金鑰外洩，歷史流量仍安全。

當我們說「通訊加密」時，通常指的是端對端加密（End-to-End Encryption）：

資料在傳輸過程中被加密，即使中間人攔截，也看不到內容。

但這裡其實還有一個潛在的風險：

如果「對方是假的」呢？

這時候，再強的加密也沒用，因為你把祕密加密傳給了錯的人。

所以除了「保密（Confidentiality）」，

我們還需要一個機制能「驗證對方的身分（Authenticity）」──這就是 數位簽章（Digital Signature）。

數位簽章是一種使用 非對稱加密 來保證：

訊息的發送者「確實是他本人」；

訊息在傳輸過程中「沒有被竄改」。

它的運作原理類似「電子版的手寫簽名」──

只是這裡簽的是一段資料的雜湊值（Hash），而不是名字。