## 巢狀類別（Nested Class）

巢狀類別指宣告在另一個類別內的類別。

### 1. 靜態巢狀類別（Static Nested Class）

- 定義：使用 static 修飾的巢狀類別。

- 位置：定義在外部類別的類別本體中，但用 static 標記。

- 存取範圍：

- 建立方式：Outer.StaticNestedClass obj = new Outer.StaticNestedClass();

- 特性：

### 2. 非靜態巢狀類別（Inner Class）

非靜態的巢狀類別，會隱式持有外部類別實例的引用，因此可以直接存取外部類別的實例成員。

### 2.1 成員內部類別（Member Inner Class）

- 定義：定義在外部類別本體中，但沒有 static 修飾。

- 位置：外部類別內部（方法之外）。

- 存取範圍：

- 建立方式：

### 2.2 本地類別（Local Class）

- 定義：宣告在方法、建構子、或區塊內的類別。

- 位置：外部類別的方法或區塊內。

- 存取範圍：

- 特性：

### 2.3 匿名類別（Anonymous Class）

- 定義：沒有名字的類別，同時宣告與建立實例。

- 位置：通常用在建立介面或抽象類別實例時，直接寫 {...}。

- 存取範圍：

- 特性：

## 對照表

## 📌 範例

public class Outer {

    private String outerField = "Outer Field"; // 封閉類別成員
    static String staticField = "Static Field";

    // 成員內部類別（Member Inner Class） ← 一般內部類別
    class MemberInnerClass {
        void printFromMemberInner() {
            // 可以直接存取封閉類別的成員
            System.out.println("MemberInnerClass -> outerField: " + outerField);
            System.out.println("MemberInnerClass -> staticField: " + staticField);
        }
    }

    // 用來示範匿名類別「實作介面」
    interface Greeter {
        void greet(String name);
    }

    void outerMethod(String param) { // ← 封閉方法
        int localVar = 42; // effectively final

        // 本地類別（Local Class）
        class LocalClass {
            void printAll() {
                // 存取封閉類別成員
                System.out.println("LocalClass -> outerField: " + outerField);
                System.out.println("LocalClass -> staticField: " + staticField);

                // 存取封閉方法變數與參數
                System.out.println("LocalClass -> localVar: " + localVar);
                System.out.println("LocalClass -> param: " + param);
            }
        }

        // 使用本地類別
        LocalClass lc = new LocalClass();
        lc.printAll();
    }

    public static void main(String[] args) {
        Outer outer = new Outer();

        // 使用成員內部類別（必須透過外部類別實例建立）
        Outer.MemberInnerClass memberInner = outer.new MemberInnerClass();
        memberInner.printFromMemberInner();

        System.out.println();

        // 呼叫包含本地類別的外部方法
        outer.outerMethod("Method Parameter");

        System.out.println();

        // ===== 匿名類別 1：實作介面 =====
        // 在 static main 中，若要取用 outer 的實例成員，需透過變數 outer（effectively final）
        Outer.Greeter greeter = new Outer.Greeter() {
            @Override
            public void greet(String name) {
                System.out.println("Greeter (anonymous) -> staticField: " + Outer.staticField);
                System.out.println("Greeter (anonymous) -> outerField via instance: " + outer.outerField);
                System.out.println("Hello, " + name);
            }
        };
        greeter.greet("Alice");

        System.out.println();

        // ===== 匿名類別 2：繼承成員內部類別並覆寫方法 =====
        Outer.MemberInnerClass anonInner = outer.new MemberInnerClass() {
            @Override
            void printFromMemberInner() {
                // 先呼叫原本行為
                super.printFromMemberInner();
                // 再加上匿名子類別自己的行為
                System.out.println("Anonymous subclass -> extra line");
            }
        };
        anonInner.printFromMemberInner();
    }
}


### 🔹 輸出：

MemberInnerClass -> outerField: Outer Field
MemberInnerClass -> staticField: Static Field

LocalClass -> outerField: Outer Field
LocalClass -> staticField: Static Field
LocalClass -> localVar: 42
LocalClass -> param: Method Parameter

Greeter (anonymous) -> staticField: Static Field
Greeter (anonymous) -> outerField via instance: Outer Field
Hello, Alice

MemberInnerClass -> outerField: Outer Field
MemberInnerClass -> staticField: Static Field
Anonymous subclass -> extra line

## 名詞介紹

### 1️⃣ 封閉類別（Enclosing Class）

- 定義在另一個類別裡的巢狀類別（nested class），它的外層類別就是它的封閉類別。

- 巢狀類別可以直接存取封閉類別的成員（包含 private）。

- 例子：成員內部類別、本地類別、匿名類別的外層類別，都是它們的封閉類別。

### 2️⃣ 封閉方法（Enclosing Method）

- 本地類別（Local Class）或匿名類別定義所在的方法、建構子或初始化區塊，就是它們的封閉方法/封閉區塊。

- 本地類別可以存取封閉方法中的final 或 effectively final 的區域變數和參數。

### 3️⃣ Final / Effectively Final 限制

- 因為本地類別存取封閉方法變數時，會捕獲變數的值。

- 若該變數會被修改，就不是 effectively final，編譯會錯。

- JDK 8 之後，不必顯式 final，但初始化後不能再改值。

## 📌 對照表